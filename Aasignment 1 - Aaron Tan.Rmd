---
title: "CITS4009 - Project 1"
author: Aaron Tan (23070356)
output: html_document
date: "2023-08-04"
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Introduction üëã
The data set analyzed can be obtained from the Kaggle platform. It‚Äôs part of the ‚ÄúGlobal YouTube Statistics 2023" https://www.kaggle.com/datasets/nelgiriyewithana/global-youtube-statistics-2023

A collection of YouTube giants, this dataset offers a perfect avenue to analyze and gain valuable insights from the luminaries of the platform. With comprehensive details on top creators' subscriber counts, video views, upload frequency, country of origin, earnings, and more, this treasure trove of information is a must-explore for aspiring content creators, data enthusiasts, and anyone intrigued by the ever-evolving online content landscape. Immerse yourself in the world of YouTube success and unlock a wealth of knowledge with this extraordinary dataset.

Video link: 

### Data loading, overview and set up: 
```{r}
library(shiny)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ca)
library(magrittr)
library(tidyverse)
library(data.table)
library(shinyWidgets)
library(leaflet)
```


#### Load the main data and display summary, str and head:

```{r}
data_path <- "C:/Users/tanaaro/Desktop/youtube/Global YouTube Statistics.csv"
# data_path <- "C:/Users/tanaaro/Desktop/youtube/Global YouTube Statistics.csv"


# df <- read.csv(data_path, sep=",", encoding = "UTF-8")
# df <- (data_path, sep=",", encoding = "UTF-8")
df <- fread(data_path, sep=",", encoding = "UTF-8")
```

```{r}
ui <- fluidPage(
  titlePanel("Exploration of Data Results:"),
  
  # Description panel using HTML elements
  div(
    h4("Summary of results:"),
    p(HTML("There are <b>995 obs</b> with <b>28 variables.</b>")),
    p("There are 4 integers, 7 characters and 17 numeric columns (variables)."),
    p("Some of the data is not consistent like 0 video views, 'nan' and 'N/A'. I will data clean these values (Transform stage) before using a new dataset to properly do the EDA analysis."),
    
    class = "description-panel",
    p("Use the tabs below to view the structure (str), summary and head (first 6 datapoints per column) statistics."),
    hr()  
  ),
  
  mainPanel(
    tabsetPanel(
      tabPanel("str", verbatimTextOutput("str_output")),
      tabPanel("summary", verbatimTextOutput("summary_output")),
      tabPanel("head", tableOutput("head_output")),
    )
  )
)

server <- function(input, output) {
  output$str_output <- renderPrint({
    str(df)
  })
  
  output$summary_output <- renderPrint({
    summary(df)
  })
  
  output$head_output <- renderTable({
    head(df, 10)
  })
}

shinyApp(ui, server)
```

### Data Cleaning/Transformation Stage üßπ
#### Stage 1: Columns underscore syntax should be consistent

```{r}
clean_df <- df %>%
  rename_all(~ gsub(" ", "_", tolower(.)))
```

<br>

#### Stage 2: Replace all the zero, NA, and NaN values with their median
```{r}
selected_columns <- c("video_views", "uploads", "country_rank", "gross_tertiary_education_enrollment_(%)", "population", "subscribers_for_last_30_days", "unemployment_rate", "channel_type_rank", "video_views_for_the_last_30_days", "urban_population", "created_year", "country")

for (col_name in selected_columns) {
  if (is.numeric(clean_df[[col_name]])) {
    median_value <- median(clean_df[[col_name]][!is.na(clean_df[[col_name]]) & !is.nan(clean_df[[col_name]]) & clean_df[[col_name]] != 0])
    
    clean_df[[col_name]][is.na(clean_df[[col_name]]) | is.nan(clean_df[[col_name]]) | clean_df[[col_name]] == 0] <- median_value
  }
}
# Figure it out how to change decimal to integer for uploads, channel_type_rank column
```

<br>

#### Stage 3: Specifically get columns required for scatterplot
```{r}
scatter_df <- clean_df %>%
  # select(subscribers, video_views, uploads, country, created_year)
  select(subscribers, video_views, uploads, created_year, 
         category, lowest_monthly_earnings, highest_monthly_earnings,
         lowest_yearly_earnings, highest_yearly_earnings, population,
         unemployment_rate, urban_population)

# Stage 4: Remove outliers by using this function forumla:
remove_outliers <- function(column) {
  q1 <- quantile(column, 0.25)
  q3 <- quantile(column, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr
  upper_bound <- q3 + 1.5 * iqr
  column[column < lower_bound | column > upper_bound] <- NA
  column
}

# New df after removing outliers
scatter_df2 <- scatter_df %>%
  mutate(created_year = remove_outliers(created_year),
         subscribers = remove_outliers(subscribers),
         video_views = remove_outliers(video_views),
         uploads = remove_outliers(uploads),
         lowest_monthly_earnings = remove_outliers(lowest_monthly_earnings),
         highest_monthly_earnings = remove_outliers(highest_monthly_earnings),
         lowest_yearly_earnings = remove_outliers(lowest_yearly_earnings),
         highest_yearly_earnings = remove_outliers(highest_yearly_earnings)
         )
```

<br>

#### Stage 4: Setup any new dfs
```{r}
bar_df <- clean_df %>%
  select("subscribers", "uploads", "unemployment_rate", "population", "youtuber", "country")

map_df <- clean_df %>%
  select("subscribers", "video_views", "uploads", "country","latitude","longitude")
```


### EDA Analysis Stage üîç
Now that the new dataset has been cleaned and transformed (ETL stage complete), we can properly perform EDA analysis to interpret the following findings:

```{r}
ui <- fluidPage(
  titlePanel("Interactive Visualisations"),
  div(
     p("Select the following options: ")
  ),
  
  sidebarLayout(
    sidebarPanel(
      selectInput("plot_type", "Select plot type:", choices = c("Scatter", "Map", "Dot Plot", "Bar Chart", "geom_line")),
      conditionalPanel(
        condition = "input.plot_type == 'Scatter'",
        
        # Later figure out how to specifically outline numerically columns
        selectInput("x_attr", "Select x-axis attribute:", names(scatter_df2)),
        selectInput("y_attr", "Select y-axis attribute:", names(scatter_df2))
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Dot Plot' || input.plot_type == 'Bar Chart'",
        selectInput("x_attr", "Select x-axis attribute:", names(scatter_df2))
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Map'",
        selectInput("d_attr", "Select size: ", names(scatter_df2))
      )
    ),
    
   mainPanel(
      conditionalPanel(
        condition = "input.plot_type != 'Map'",
        plotOutput("plot", height = "400px", width = "600px")
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Map'",
        leafletOutput("map", height = "400px", width = "600px")
      )
    )
  )
)

# Define the server
server <- function(input, output) {
  
  output$map <- renderLeaflet({
    d_attr <- input$d_attr
    lat <- map_df$latitude
    long <- map_df$longitude
    
    print(head(map_df[[d_attr]],10))
    
    if (d_attr == "subscribers") {
      radius_multiplier <- 1 / 8000000
      radius_color <- "darkred"
    } else if (d_attr == "video_views") {
      radius_multiplier <- 1 / 6000000000
      radius_color <- "darkblue"
    } else if (d_attr == "uploads"){
      radius_multiplier <- 1 / 10000
      radius_color <- "green"
    } else if (d_attr == "lowest_monthly_earnings"){
      radius_multiplier <- 1 / 10000
      radius_color <- "green"
    }

    leaflet() %>%
      addTiles() %>%
      setView(lng = mean(long, na.rm = TRUE), lat = mean(lat, na.rm = TRUE), zoom = 2) %>%
      addCircleMarkers(
        data = map_df,
        lng = long,
        lat = lat,
        radius = map_df[[d_attr]] * radius_multiplier,
        color = radius_color,
        fillOpacity = 0.7,
        popup = paste("Country: ", map_df$country, "<br>", d_attr, map_df[[d_attr]])
      )
  })
  
  output$plot <- renderPlot({
    if (input$plot_type == "Scatter") {
      x_attr <- input$x_attr
      y_attr <- input$y_attr
      
      # print(paste("datatype: ", class(x_attr)))
      
      ggplot(scatter_df2, aes_string(x = x_attr, y = y_attr)) +
        geom_point() +
        geom_smooth(span = 0.1) +
        labs(title = paste(x_attr, " amount by ", y_attr))
    
    # Work on Dot Plot, displayed the wrong values
    }else if(input$plot_type == "Dot Plot"){
      print(class(bar_df))
      # The x_attr has to be here
      x_attr <- input$x_attr
      
      # All the values from x_attr based on bar_df data
      # 245000000 170000000 166000000 162000000
      values <- bar_df[[x_attr]]
      
      print(head(values, 10))
  
      aggregated_data <- bar_df %>%
        print() %>%
        group_by(country) %>%
        
        # Why it applies all the mean to all countries instead of it each country?
        summarize(total_value = sum(values, na.rm = T))
      
      sorted_data <- aggregated_data[order(aggregated_data$total_value, decreasing = TRUE), ]
      
     # print(names(sorted_data))
      #print(head(sorted_data, 70))
      
      # Make the visualisation clean by showing only the top 5 countries.
      top_countries <- head(sorted_data, 5) 
      
      ggplot(top_countries, aes(x = total_value, y = reorder(country, total_value))) +
      geom_segment(aes(xend = 0, yend = country), color = "grey") +  # Add connecting lines
      geom_point(color = "dodgerblue", size = 4) +  
      geom_text(aes(label = total_value), vjust = 3
                -2.5, hjust = -0.8, color = "black", size = 3) + 
      labs(title = "Top 5 Countries by <x-axis title here>",
           x = "<x-axis here>",
           y = "Country") +f
      theme_minimal() +
      scale_x_continuous(position = "top")  # Move x-axis to top
    
    }else if(input$plot_type == "Bar Chart"){
      # Youtubers in y-axis
      # values on x-axis e.g subscribers
      
      x_attr <- input$x_attr
      y_attr <- bar_df$youtuber
      
      # print(head(bar_df[[x_attr]], 10))
      
   
      top_data <- head(bar_df[order(bar_df[[x_attr]], decreasing = TRUE), ], 10)
      top_data$x_values <- top_data[[x_attr]]
  
      top_data$y_attr_clean <- gsub("[^a-zA-Z0-9\\s.,!?&\'-]", "", top_data$youtuber)
      
      print(class(top_data))
      print(head(top_data, 10))
      
      ggplot(top_data, aes_string(x = x_attr, y = "y_attr_clean")) +
        geom_bar(stat = "identity", fill = "steelblue") +
        labs(title = paste("Top 10 YouTube Channels by No.", x_attr), x = x_attr, y = "YouTuber")
      
      
    }else if(input$plot_type == "Pie Chart"){
      
    }
  })
}

# Run the Shiny app
shinyApp(ui, server)

```


### Business Queries:
#### 1. Correlation between Number of Subscribers and the Number of Video Views
The correlation for both subscribers and views showcase that the number of YouTubers are primarily under 25% during the era in 2010-2015 and the correlation of that the higher the views and the subscribers, it typically rare for YouTubers to acquire high amount of views and subscribers. 


```{r, warning=FALSE}
# Figure out how to change the ggplot size later
p1 <- ggplot(data = scatter_df2, mapping = aes(x = scatter_df2$subscribers, y = scatter_df2$created_year, color = (scatter_df2$created_year >= 2010 & scatter_df2$created_year <= 2015))) +
  geom_point() +
  scale_color_manual(values = c("FALSE" = "gray", "TRUE" = "red"),
  name = "Legend:",
  labels = c("Before 2010", "2010-2015")) +
  geom_smooth(span=0.1) +
  labs(x = "Subscribers Scatterplot", y = "Year") +
  ggtitle("Subscribers")

p2 <- ggplot(data = scatter_df2, mapping = aes(x = scatter_df2$video_views, y = scatter_df2$created_year, color = (scatter_df2$created_year >= 2010 & scatter_df2$created_year <= 2015))) +
  geom_point() +
  scale_color_manual(values = c("FALSE" = "gray", "TRUE" = "red"),
  name = "Legend:",
  labels = c("Before 2010", "2010-2015")) +
  geom_smooth(span=0.1) +
  labs(x = "Views", y = "Year") +
  ggtitle("Video_views")

grid.arrange(p1, p2, ncol=1)

```

#### 2. Top 10 YouTube Channels by No. Subscribers (2023) (Bar Chart)
You can see that T-Series has the highest amount of subscribers.
```{r}
top_data <- head(bar_df[order(bar_df$subscribers, decreasing = TRUE), ], 10)
ggplot(top_data, aes_string(x = "subscribers", y = "youtuber")) +
        geom_bar(stat = "identity", fill = "steelblue") +
        labs(title = "Top 10 YouTube Channels by No. Youtuber", x = "Subscribers", y = "YouTuber")
```

#### 3. Top 10 YouTube Channels Categories (2023) (Bar Chart)

```{r}
# How to count the number of channel_type?
top_data <- head(bar_df[order(bar_df$channel_type, decreasing = TRUE), ], 10)


aggregated_data <- top_data %>%
  print() %>%
  group_by(channel_type) %>%
  
  # Why it applies all the mean to all countries instead of it each country?
  summarize(total_value = sum(values, na.rm = T))

ggplot(top_data, aes_string(x = "channel_type", y = values)) +
        geom_bar(stat = "identity", fill = "steelblue") +
        labs(title = "Top 10 YouTube Channels by No. Channel Type", x = "Channel Type", y = "YouTuber")
```

#### 4. Which Countries have the Highest Number of YouTubers? (Pie Chart)
As you can see....

#### 5. Map comparsion

### Conclusion/Summary üìã
In Conclusion, blah blah blah here


