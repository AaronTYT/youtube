---
title: "CITS4009 - Project 1"
author: Aaron Tan (23070356)
output: html_document
date: "2023-08-04"
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Introduction üëã
The data set analyzed can be obtained from the Kaggle platform. It‚Äôs part of the ‚ÄúGlobal YouTube Statistics 2023" https://www.kaggle.com/datasets/nelgiriyewithana/global-youtube-statistics-2023

A collection of YouTube giants, this dataset offers a perfect avenue to analyze and gain valuable insights from the luminaries of the platform. With comprehensive details on top creators' subscriber counts, video views, upload frequency, country of origin, earnings, and more, this treasure trove of information is a must-explore for aspiring content creators, data enthusiasts, and anyone intrigued by the ever-evolving online content landscape. Immerse yourself in the world of YouTube success and unlock a wealth of knowledge with this extraordinary dataset.

Video link: youtube_link here

### Data loading, overview and set up: 
```{r}
library(shiny)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ca)
library(magrittr)
library(tidyverse)
library(data.table)
library(shinyWidgets)
library(leaflet)
```

#### Load the main data and display summary, str and head:
```{r}
#data_path <- "C:/Users/tanaaro/Desktop/youtube/Global YouTube Statistics.csv"
data_path <- "C:/Users/tanaaro/Desktop/youtube/Global YouTube Statistics.csv"
df <- fread(data_path, sep=",", encoding = "UTF-8")
```

```{r}
ui <- fluidPage(
  titlePanel("Exploration of Data Results:"),
  
  # Description panel using HTML elements
  div(
    h4("Summary of results:"),
    p(HTML("There are <b>995 obs</b> with <b>28 variables.</b>")),
    p("There are 4 integers, 7 characters and 17 numeric columns (variables)."),
    p("Some of the data is not consistent like 0 video views, 'nan' and 'N/A'. I will data clean these values (Transform stage) before using a new dataset to properly do the EDA analysis."),
    
    class = "description-panel",
    p("Use the tabs below to view the structure (str), summary and head (first 6 datapoints per column) statistics."),
    hr()  
  ),
  
  mainPanel(
    tabsetPanel(
      tabPanel("str", verbatimTextOutput("str_output")),
      tabPanel("summary", verbatimTextOutput("summary_output")),
      tabPanel("head", tableOutput("head_output")),
    )
  )
)

server <- function(input, output) {
  output$str_output <- renderPrint({
    str(df)
  })
  
  output$summary_output <- renderPrint({
    summary(df)
  })
  
  output$head_output <- renderTable({
    head(df, 10)
  })
}

shinyApp(ui, server)
```

### Data Cleaning/Transformation Stage üßπ
#### Stage 1: Columns underscore syntax should be consistent
```{r}
clean_df <- df %>%
  rename_all(~ gsub(" ", "_", tolower(.)))
```

<br>

#### Stage 2: Replace all the zero, NA, and NaN values with their median
```{r}
selected_columns <- c("video_views", "uploads", "country_rank", "gross_tertiary_education_enrollment_(%)", "population", "subscribers_for_last_30_days", "unemployment_rate", "channel_type_rank", "video_views_for_the_last_30_days", "urban_population", "created_year", "country")

for (col_name in selected_columns) {
  if (is.numeric(clean_df[[col_name]])) {
    median_value <- median(clean_df[[col_name]][!is.na(clean_df[[col_name]]) & !is.nan(clean_df[[col_name]]) & clean_df[[col_name]] != 0])
    clean_df[[col_name]][is.na(clean_df[[col_name]]) | is.nan(clean_df[[col_name]]) | clean_df[[col_name]] == 0] <- median_value
  }
}
# Figure it out how to change decimal to integer for uploads, channel_type_rank column
```

<br>

#### Stage 3: Specifically get columns required for scatterplot
```{r}
scatter_df <- clean_df %>%
  # select(subscribers, video_views, uploads, country, created_year)
  select(subscribers, video_views, uploads, created_year, 
         category, lowest_monthly_earnings, highest_monthly_earnings,
         lowest_yearly_earnings, highest_yearly_earnings, population,
         unemployment_rate, urban_population)

# Stage 4: Remove outliers by using this function formula:
remove_outliers <- function(column) {
  q1 <- quantile(column, 0.25)
  q3 <- quantile(column, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr
  upper_bound <- q3 + 1.5 * iqr
  column[column < lower_bound | column > upper_bound] <- NA
  column
}

# New df after removing outliers
scatter_df2 <- scatter_df %>%
  mutate(created_year = remove_outliers(created_year),
         subscribers = remove_outliers(subscribers),
         video_views = remove_outliers(video_views),
         uploads = remove_outliers(uploads),
         lowest_monthly_earnings = remove_outliers(lowest_monthly_earnings),
         highest_monthly_earnings = remove_outliers(highest_monthly_earnings),
         lowest_yearly_earnings = remove_outliers(lowest_yearly_earnings),
         highest_yearly_earnings = remove_outliers(highest_yearly_earnings)
         )
```

<br>

#### Stage 4: Setup any new dfs
```{r}
bar_df <- clean_df %>%
  select("subscribers", "highest_yearly_earnings", "uploads", "unemployment_rate", "population", "youtuber", "country")

map_df <- clean_df %>%
  select("subscribers", "video_views", "uploads", "country","latitude","longitude")
```

### EDA Analysis Stage üîç
Now that the new dataset has been cleaned and transformed (ETL stage complete), we can properly perform EDA analysis to interpret the following findings:
```{r}
ui <- fluidPage(
  titlePanel("Interactive Visualisations"),
  div(
     p("Select the following options: ")
  ),
  
  sidebarLayout(
    sidebarPanel(
      selectInput("plot_type", "Select plot type:", choices = c("Scatter", "Map", "Dot Plot", "Bar Chart", "Pie Chart")),
      conditionalPanel(
        condition = "input.plot_type == 'Scatter'",
        
        # Later figure out how to specifically outline numerically columns
        selectInput("x_attr", "Select x-axis attribute:", names(scatter_df2)),
        selectInput("y_attr", "Select y-axis attribute:", names(scatter_df2))
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Dot Plot' || input.plot_type == 'Bar Chart' || input.plot_type == 'Pie Chart'",
        selectInput("x_attr", "Select x-axis attribute:", names(scatter_df2))
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Map'",
        selectInput("d_attr", "Select size: ", names(scatter_df2))
      )
    ),
    
   mainPanel(
      conditionalPanel(
        condition = "input.plot_type != 'Map'",
        plotOutput("plot", height = "400px", width = "600px")
      ),
      conditionalPanel(
        condition = "input.plot_type == 'Map'",
        leafletOutput("map", height = "400px", width = "600px")
      )
    )
  )
)

# Define the server
server <- function(input, output) {
  
  output$map <- renderLeaflet({
    d_attr <- input$d_attr
    lat <- map_df$latitude
    long <- map_df$longitude
    
    print(head(map_df[[d_attr]],10))
    
    if (d_attr == "subscribers") {
      radius_multiplier <- 1 / 8000000
      radius_color <- "darkred"
    } else if (d_attr == "video_views") {
      radius_multiplier <- 1 / 6000000000
      radius_color <- "darkblue"
    } else if (d_attr == "uploads"){
      radius_multiplier <- 1 / 10000
      radius_color <- "green"
    } else if (d_attr == "lowest_monthly_earnings"){
      radius_multiplier <- 1 / 10000
      radius_color <- "green"
    }

    leaflet() %>%
      addTiles() %>%
      setView(lng = mean(long, na.rm = TRUE), lat = mean(lat, na.rm = TRUE), zoom = 2) %>%
      addCircleMarkers(
        data = map_df,
        lng = long,
        lat = lat,
        radius = map_df[[d_attr]] * radius_multiplier,
        color = radius_color,
        fillOpacity = 0.7,
        popup = paste("Country: ", map_df$country, "<br>", d_attr, map_df[[d_attr]]) 
      )
  })
  
  output$plot <- renderPlot({
    if (input$plot_type == "Scatter") {
      x_attr <- input$x_attr
      y_attr <- input$y_attr
      
      ggplot(scatter_df2, aes_string(x = x_attr, y = y_attr)) +
        geom_point() +
        geom_smooth(span = 0.1) +
        labs(title = paste(x_attr, " amount by ", y_attr))
    
    }else if(input$plot_type == "Dot Plot"){
      x_attr <- input$x_attr
      values <- bar_df[[x_attr]]
  
      aggregated_data <- bar_df %>%
        group_by(country) %>%
        summarize(total_value = sum(values, na.rm = T))
      
      sorted_data <- aggregated_data[order(aggregated_data$total_value, decreasing = TRUE), ]
      
      top_countries <- head(sorted_data, 5)
      
      ggplot(top_countries, aes(x = total_value, y = reorder(country, total_value))) +
      geom_segment(aes(xend = 0, yend = country), color = "grey") +  # Add connecting lines
      geom_point(color = "dodgerblue", size = 4) +
      geom_text(aes(label = total_value), vjust = 3
                -2.5, hjust = -0.8, color = "black", size = 3) + 
      labs(title = paste("Top 5 Countries by", country),
           x = "Subscribers",
           y = "Country") +
      theme_minimal() +
      scale_x_continuous(position = "top")  # Move x-axis to top
    
    }else if(input$plot_type == "Bar Chart"){
      x_attr <- input$x_attr
      y_attr <- bar_df$youtuber
      
      top_data <- head(bar_df[order(bar_df[[x_attr]], decreasing = TRUE), ], 10)
      top_data$x_values <- top_data[[x_attr]]
      
      top_data$y_attr_clean <- gsub("[^a-zA-Z0-9\\s.,!?&\'-]", " ", top_data$youtuber)
      top_data <- top_data[order(-top_data[[x_attr]]), ]
      
      ggplot(top_data, aes(x = x_values, y = y_attr_clean)) +
        geom_bar(stat = "identity", fill = "steelblue") +
        geom_text(aes(label = x_values), vjust = 0.5, hjust = 1.1, color = "white", size = 3.5, fontface = "bold") +
        labs(title = paste("Top 10 YouTube Channels by No.", x_attr), x = x_attr, y = "YouTuber") +
        theme_minimal()

      
    }else if(input$plot_type == "Pie Chart"){
      x_attr <- input$x_attr
  
      top_data <- head(bar_df[order(bar_df[[x_attr]], decreasing = TRUE), ], 10)
      top_data$x_values <- top_data[[x_attr]]
      
      top_data$y_attr_clean <- gsub("[^a-zA-Z0-9\\s.,!?&\'-]", " ", top_data$youtuber)
      top_data <- top_data[order(-top_data[[x_attr]]), ]
      
      ggplot(top_data, aes(x = "", y = x_values, fill = y_attr_clean)) +
        geom_bar(stat = "identity") +
        coord_polar(theta = "y") +  # Create a pie chart
        labs(title = paste("Countries %", x_attr), x = NULL, y = NULL) +
        theme_minimal() +
        theme(legend.position = "bottom")  # Adjust legend position
    }
  })
}

# Run the Shiny app
shinyApp(ui, server)

```


### Business Queries:
#### 1. Correlation between Number of Subscribers and Earnings (per year)
The correlation for both subscribers and highest_yearly_earnings showcase that vast majority of subscribers will earn
lower compared to those who have higher subscribers but that does not necessary mean it will generally have higher earnings.
For instance, some subscribers have low amount of subscribers but yet they achieved great earning results and some do have higher subscribers
but the earnings are low. Not much youtubers who can achieve a high amount of subscribers is necessary to achieve high earnings based on subscribers alone, it can affect the amount of earnings such as marketing campaigns to buy more products etc.

```{r, warning = FALSE }
# Figure out how to change the ggplot size later
ggplot(data = scatter_df2, mapping = aes(x = scatter_df2$subscribers, y = scatter_df2$highest_yearly_earnings)) +
  geom_point() + 
  geom_smooth(method = "lm", formula = y ~ x) +
  labs(x = "No. of Subscribers", y = "$ per year") +
  ggtitle("Subscribers Earnings per Year")


summary(scatter_df2$subscribers)
summary(scatter_df2$highest_yearly_earnings)
```

#### 2. Top 10 YouTube Channels by No. Subscribers
T-Series has the highest amount of subscribers, followed by YouTube Movies and after that MrBeast. The next graph showcase whether those youtubers has the highest amount of earnings because of the number of subscribers that have?

```{r, warning = FALSE }
top_data <- head(bar_df[order(bar_df$subscribers, decreasing = TRUE), ], 10)
top_data$clean_youtuber <- gsub("[^a-zA-Z0-9\\s.,!?&\'-]", " ", top_data$youtuber)
ggplot(top_data, aes_string(x = "subscribers", y = "clean_youtuber")) +
        geom_bar(stat = "identity", fill = "steelblue") +
        geom_text(aes_string(label = "subscribers"), vjust = 0.5, hjust = 1.1, color = "white", size = 3.5, fontface = "bold") +
        labs(title = "Top 10 YouTubers by No. Subscribers", x = "Subscribers", y = "YouTuber")
```

#### 3. Top 10 YouTube Channels Max Year Earnings 
It not necessary true that the higher the amount of subscribers, the higher the earning potential that a Youtuber can produce. As you can see below, KIMPRO has the highest amount of earnings per year followed by DaFuq!?Boom! and after that T-Series. T-Series does showcase the highest amount of subscribers but it is the 3rd highest earning per year.
```{r}
# How to count the number of max year earnings?
top_data <- head(bar_df[order(bar_df$highest_yearly_earnings, decreasing = TRUE), ], 10)
top_data$clean_youtuber <- gsub("[^a-zA-Z0-9\\s.,!?&\'-]", " ", top_data$youtuber)
ggplot(top_data, aes_string(x = "highest_yearly_earnings", y = "clean_youtuber")) +
        geom_bar(stat = "identity", fill = "steelblue") +
        geom_text(aes_string(label = "highest_yearly_earnings"), vjust = 0.5, hjust = 1.1, color = "white", size = 3.5, fontface = "bold") +
        labs(title = "Top 10 YouTubers by their max earnings per Year ($)", x = "Max Earnings per Year ($)", y = "YouTuber")
```

#### 4. Top 10 Countries shows subscribers and max earnings comparsion
As you can see, every youtuber based on their country is added up their earnings and subscribers to represent which country contains the highest earnings and subscribers. We can definitely correlate that United States of America tends to have the highest earnings and subscribers, followed by India. Since majority of the world population's main language is English, it makes sense to see that majority of the population will be marketed towards English speakers.
```{r}
top10_country_max <- bar_df %>%
  group_by(country) %>%
  summarise(max_earnings = round(sum(highest_yearly_earnings)/10000000)) %>%
  arrange(desc(max_earnings)) %>%
  head(10)

top10_country_sub <- bar_df %>%
  group_by(country) %>%
  summarise(subscribers = round(sum(subscribers)/10000000)) %>%
  arrange(desc(subscribers)) %>%
  head(10)

p1 <- ggplot(top10_country_max, aes(x = max_earnings, y = country)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes_string(label = "max_earnings"), vjust = 0.5, hjust = 1.1,   color = "white", size = 3.5, fontface = "bold") +
  labs(title = "Top 10 Countries by Maximum Earnings",
       x = "Earnings (10M)",
       y = "Country")

p2 <- ggplot(top10_country_sub, aes(x = subscribers, y = country)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes_string(label = "subscribers"), vjust = 0.5, hjust = 1.1,   color = "white", size = 3.5, fontface = "bold") +
  labs(title = "Top 10 Countries by Subscribers",
       x = "Subscribers (10M)",
       y = "Country")

grid.arrange(p1, p2)
```

### Conclusion/Summary üìã
In Conclusion, 

#### Improvements in the near future
Bar Chart:

* Values can be displayed to cut into smaller digits (e.g. 1M) if the values gets too large, sort the YouTuber's data from biggest bar to lowest bar to see better comparison. 
* Ability to add a slider option not just fixed to only 10 YouTubers, it can showcase based on their selection for only the max. E.g I want to show 5 YouTubers.


Add more variety of plot-types and enable functionality in shiny-app interaction and added additional data analysis for better insights to answer impactful queries.



